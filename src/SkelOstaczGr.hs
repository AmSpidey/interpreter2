module SkelOstaczGr where

-- Haskell module generated by the BNF converter

import AbsOstaczGr
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

data Value = ValInt Integer | ValS String | ValB BVAL deriving (Ord, Eq, Show)
instance Num Value where
  ValInt a + ValInt b = ValInt $ a + b
  ValInt a - ValInt b = ValInt $ a - b
  ValInt a * ValInt b = ValInt $ a * b
instance Real Value where
  toRational (ValInt a) = toRational a
instance Enum Value where
  fromEnum (ValInt a) = fromEnum (a)
instance Integral Value where
  mod (ValInt a) (ValInt b) = ValInt $ mod a b
  quot (ValInt a) (ValInt b) = ValInt $ quot a b

type Interpretation a = Maybe a
{-ValInt a '+' ValInt b = ValInt $ a + b
ValInt a '-' ValInt b = a - b
ValInt a '*' ValInt b = a * b
ValInt a '/' ValInt b = a / b-}

-- TODO
-- turn it into Maybe Value function and handle the errors (int + string = left)
-- TODO
-- beautify all the dos in EAdd, EMul
interpretExpr :: Expr -> Interpretation Value
interpretExpr (ELitInt integer) = Just $ ValInt integer
interpretExpr (ELitBool bval) = Just $ ValB bval
interpretExpr (EString string) = Just $ ValS string
interpretExpr (EAdd expr1 op expr2)  = do
                                              v1 <- interpretExpr expr1
                                              v2 <- interpretExpr expr2
                                              case op of
                                                Plus -> return $ v1 + v2
                                                Minus -> return $ v1 - v2

interpretExpr (EMul expr1 op expr2) = do
                                               v1 <- interpretExpr expr1
                                               v2 <- interpretExpr expr2
                                               case op of
                                                 Times -> return $ v1 * v2
                                                 Div -> return $ quot v1 v2
                                                 Mod -> return $ mod v1 v2

interpretExpr _ = Nothing

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transBVAL :: BVAL -> Result
transBVAL x = case x of
  BVAL string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Prog topdefs -> failure x
transTopDef :: TopDef -> Result
transTopDef x = case x of
  FnDef type_ ident args block -> failure x
transArg :: Arg -> Result
transArg x = case x of
  ArgByVal type_ ident -> failure x
  ArgByVar type_ ident -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  BlockStmt stmts -> failure x
transStmt :: Stmt -> Result
transStmt x = case x of
  Empty -> failure x
  BStmt block -> failure x
  Decl type_ items -> failure x
  Ass ident expr -> failure x
  Incr ident -> failure x
  Decr ident -> failure x
  Ret expr -> failure x
  VRet -> failure x
  Cond expr stmt -> failure x
  CondElse expr stmt1 stmt2 -> failure x
  Subsection ident block -> failure x
  SubsectionPaid ident expr block -> failure x
  Repeat -> failure x
  Finish -> failure x
  Earn expr -> failure x
  RepeatXTimes expr -> failure x
  SExp expr -> failure x
transItem :: Item -> Result
transItem x = case x of
  NoInit ident -> failure x
  Init ident expr -> failure x
transType :: Type -> Result
transType x = case x of
  Int -> failure x
  Str -> failure x
  Bool -> failure x
  Void -> failure x
transExpr :: Expr -> Result
transExpr x = case x of
  EVar ident -> failure x
  ELitInt integer -> failure x
  ELitBool bval -> failure x
  EApp ident exprs -> failure x
  EString string -> failure x
  Neg expr -> failure x
  Not expr -> failure x
  EMul expr1 mulop expr2 -> failure x
  EAdd expr1 addop expr2 -> failure x
  ERel expr1 relop expr2 -> failure x
  EAnd expr1 expr2 -> failure x
  EOr expr1 expr2 -> failure x
transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus -> failure x
  Minus -> failure x
transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times -> failure x
  Div -> failure x
  Mod -> failure x
transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH -> failure x
  LE -> failure x
  GTH -> failure x
  GE -> failure x
  EQU -> failure x
  NE -> failure x

